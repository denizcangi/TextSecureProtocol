# -*- coding: utf-8 -*-
"""Client_phase3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fEvS4buem7WRMzID8f821Q0u-UmXEDmv
"""

import math
import timeit
import random
import sympy
import warnings
from random import randint, seed
import sys
from ecpy.curves import Curve,Point
from Crypto.Hash import SHA3_256, SHA256, HMAC
import requests
from Crypto.Cipher import AES
from Crypto import Random
from Crypto.Util.Padding import pad
from Crypto.Util.Padding import unpad
import random
import hashlib, hmac, binascii
import json
API_URL = 'http://cryptlygos.pythonanywhere.com'

stuID =  25427 
stuID_B = 18007
max_ephemeral_keys = 10

#create a long term key

curve = Curve.get_curve('secp256k1')
q = curve.order
p = curve.field
P = curve.generator

sL = 53716276452879763011299912978312200023113462058595331715998454673181512732025
QCli_long = Point(0xd013d75d64b4d4832b7fc6a8d62ca1686828ea0b9e1b447876469363952f53b7 , 0x1bc473594de94fb59f8410b483fb597057bf862ecfda73c45fd06c57051b9180,curve)

def SignSL(message):
  k = Random.new().read(int(math.log(q-2,2)))
  k = int.from_bytes(k, byteorder='big')%q
  R = k*P
  r = R.x % q
  mr = bytes(message, 'utf-8')+ r.to_bytes((r.bit_length()+7)//8, byteorder = 'big')
  hashVal = SHA3_256.new(mr)
  h = int.from_bytes(hashVal.digest(), 'big') % q
  s = (sL*h + k)%q 
  return s,h

def Encryption(k_enc, k_mac, plaintext):
  cipher = AES.new(k_enc, AES.MODE_CTR)
  message_without_nonce = cipher.encrypt(plaintext)
  HMAC_val = HMAC.new(k_mac, message_without_nonce, digestmod=SHA256)
  hmac = HMAC_val.digest()
  ctext = cipher.nonce + message_without_nonce + hmac
  ctext = int.from_bytes(ctext, byteorder='big')
  return ctext

def Decryption(ctext,key,nonce_len):
  ctext = ctext.to_bytes((ctext.bit_length()+7)//8, byteorder = 'big')
  cipher = AES.new(key, AES.MODE_CTR, nonce=ctext[0:nonce_len])
  dtext = cipher.decrypt(ctext[nonce_len:])
  decrypt_text = dtext.decode('utf-8')
  return decrypt_text

def SessionKeyGen(i, QBj_x, QBj_y, Dict):
  QBj = Point(QBj_x, QBj_y, curve)

  sA = Dict[i]
  T = sA * QBj
  message_for_U = "NoNeedToRunAndHide"
  U = str(T.x) + str(T.y) + message_for_U

  hashVal= SHA3_256.new(bytes(U, 'utf-8'))
  k_enc = hashVal.digest()

  hashVal_ = SHA3_256.new(k_enc)
  k_mac = hashVal_.digest()

  return k_enc, k_mac

####Register Long Term Key
"""
s, h = SignSL(str(stuID))

mes = {'ID':stuID, 'H': h, 'S': s, 'LKEY.X': QCli_long.x, 'LKEY.Y': QCli_long.y}
response = requests.put('{}/{}'.format(API_URL, "RegLongRqst"), json = mes)
print(response.json())

code = int(input())

mes = {'ID':stuID, 'CODE': code}
response = requests.put('{}/{}'.format(API_URL, "RegLong"), json = mes)
print(response.json())
"""
s, h = SignSL(str(stuID))

#Check Status
mes = {'ID_A':stuID, 'H': h, 'S': s}
response = requests.get('{}/{}'.format(API_URL, "Status"), json = mes)
print("Status ", response.json())

response_str = response.json()

need_to_send = response_str[response_str.find("send") + 5:response_str.rfind("keys")-1]
need_int = int(need_to_send)

unread_message = response_str[response_str.rfind("have") + 5:response_str.rfind("unread")-1]
unread_int = int(unread_message)

#dictionary of the ephemeral key id and the corresponding private ephemeral key
Dict = {0: 23712741026079747155097710476681469586924281034851461170426736097180196380258, 1: 25160065460140021472001208005828312780133160910400542385138505754343155957822, 2: 19293962143953789228611165935176849947089110725847659829599326383964061906343, 3: 16623247583761219277555046080781308171479376600328373610189214617484041444123, 4: 48401617962051768187668716928181107217797023731823887740929423397155873605281, 5: 59198619607053516494585800872681037046360806929398978500977341089567659106869, 6: 88831220244094373407190889328792341780270568787808380866362428609433327719288, 7: 77903326411752008467438393738526091996790280089579328065526348506076812233881, 8: 75925101417301140765565665951362885970451668182118735065398562567220701576738, 9: 17404722995144424573512762964288509408423676520076250710855009781675588522311}

print("Dictionary that keeps the ephemeral private keys with the ID =", Dict)

### Get key of the Student B

s, h = SignSL(str(stuID_B))
mes = {'ID_A': stuID, 'ID_B':stuID_B, 'S': s, 'H': h}
response = requests.get('{}/{}'.format(API_URL, "ReqKey"), json = mes)
res = response.json()
print(res)

if res!= str(stuID_B)+" has no ephemeral key":

  i = int(res.get('i')) 
  j = int(res.get('j'))

  QBj_x = res.get('QBJ.x')
  QBj_y = res.get('QBJ.y')

  k_enc, k_mac = SessionKeyGen(i, QBj_x, QBj_y, Dict)
  myMessage = "Love is like taking a dump, Butters. Sometimes it works itself out. But sometimes, you need to give it a nice hard slimy push."
  myMessage_bytes = bytes(myMessage, 'utf-8')

  msg = Encryption(k_enc, k_mac, myMessage_bytes)

  ### Send message to student B
  mes = {'ID_A': stuID, 'ID_B':stuID_B, 'I': i, 'J':j, 'MSG': msg}
  response = requests.put('{}/{}'.format(API_URL, "SendMsg"), json = mes)
  print(response.json())


## Get your message

for k in range(unread_int):
  s, h = SignSL(str(stuID))
  mes = {'ID_A': stuID, 'S': s, 'H': h}
  response = requests.get('{}/{}'.format(API_URL, "ReqMsg_PH3"), json = mes)
  print(response.json())
  if(response.ok): ## Decrypt message
    res= response.json()

    if res == "You dont have any new messages":
      break

    keyID = int(res.get('KEYID'))
    message = res.get('MSG')
    #ephemeral public key of the pseudo-client
    QBj_x = res.get('QBJ.X')
    QBj_y = res.get('QBJ.Y')
    QBj = Point(QBj_x, QBj_y, curve)

    sA = Dict[keyID]
    T = sA * QBj
    message_for_U = "NoNeedToRunAndHide"
    U = str(T.x) + str(T.y) + message_for_U

    hashVal= SHA3_256.new(bytes(U, 'utf-8'))
    k_enc = hashVal.digest()

    hashVal_ = SHA3_256.new(k_enc)
    k_mac = hashVal_.digest()

    #Whole message with nonce-message itself-hmac is converted into byte array
    msg_bytes = message.to_bytes((message.bit_length() + 7)//8, byteorder= 'big')
    #Last 32 bytes is the hmac
    HMAC_extracted = msg_bytes[len(msg_bytes)-32:]
    #First portion is the nonce and the message itself
    message_withnonce = msg_bytes[:len(msg_bytes)-32]
    #message without nonce to get the MAC of the message
    message_without_nonce = msg_bytes[8:len(msg_bytes)-32]
    #message in int format to decrypt it
    message_int = int.from_bytes(message_withnonce, 'big')

    #get the HMAC-SHA256 of the message with k_mac
    HMAC_val = HMAC.new(k_mac, message_without_nonce, digestmod=SHA256)
    hmac = HMAC_val.digest()

    #if the mac computed and mac extracted from the message are the same then the message is authenticated
    if hmac == HMAC_extracted:
      print("The MAC of the message is verified, it is authentic!")
    else:
      print("The message is not authentic!")

    decrypted_text = Decryption(message_int, k_enc, 8)
    print("The decrypted message is:", decrypted_text)

#The following part handles the key exhange. If 2 of the keys have been used by the other party of the communication, we directly compansate
#2 keys and add that to the dictionary. Therefore, no matter the runtime history of the receiver, it is always ready to receive 10 messages securely.

max_key = max(Dict) + 1

for i in range(need_int):
  sA = Random.new().read(int(math.log(q-1,2)))
  sA = int.from_bytes(sA, byteorder='big') % q

  Dict[max_key] = sA

  ekey = sA*P
  toMessage = str(ekey.x) + str(ekey.y)
  s, h = SignSL(toMessage)
  print()
  #Send Ephemeral keys
  mes = {'ID': stuID, 'KEYID': max_key , 'QAI.X': ekey.x, 'QAI.Y': ekey.y, 'Si': s, 'Hi': h}
  response = requests.put('{}/{}'.format(API_URL, "SendKey"), json = mes)
  print(response.json())
  max_key+=1

print("The updated dictionary =", Dict)