# -*- coding: utf-8 -*-
"""Client_phase2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1y0inmmSo-lhUSv4ntHXwIMJ6qCc_0C-T
"""

pip install ecpy

pip install pycryptodome

import math
import timeit
import random
import sympy
import warnings
from random import randint, seed
import sys
from ecpy.curves import Curve,Point
from Crypto.Hash import SHA3_256, HMAC, SHA256
import requests
from Crypto.Cipher import AES
from Crypto import Random
from Crypto.Util.Padding import pad
from Crypto.Util.Padding import unpad
import random
import re
import json

API_URL = 'http://cryptlygos.pythonanywhere.com'

#CRYPTOGRAPHY CS411 FALL 2020 TERM RPOJECT PHASE 2
#Developing software for receiving messages from other clients

#IMPLEMENTED BY DENIZ CANGI, GULSEN GORKEM KOSE

stuID =  25427

#GET THE CURVE, ORDER, FIELD AND GENERATOR
curve = Curve.get_curve('secp256k1')
q = curve.order
p = curve.field
P = curve.generator

sL = 53716276452879763011299912978312200023113462058595331715998454673181512732025
QCli_long = Point(0xd013d75d64b4d4832b7fc6a8d62ca1686828ea0b9e1b447876469363952f53b7 , 0x1bc473594de94fb59f8410b483fb597057bf862ecfda73c45fd06c57051b9180,curve)

#server's long term key
QSer_long = Point(0xc1bc6c9063b6985fe4b93be9b8f9d9149c353ae83c34a434ac91c85f61ddd1e9 , 0x931bd623cf52ee6009ed3f50f6b4f92c564431306d284be7e97af8e443e69a8c, curve)

def SignSL(message):
  k = Random.new().read(int(math.log(q-2,2)))
  k = int.from_bytes(k, byteorder='big')%q
  R = k*P
  r = R.x % q
  mr = bytes(message, 'utf-8')+ r.to_bytes((r.bit_length()+7)//8, byteorder = 'big')
  hashVal = SHA3_256.new(mr)
  h = int.from_bytes(hashVal.digest(), 'big') % q
  s = (sL*h + k)%q 
  return s,h

def Decryption(ctext,key,nonce_len):
  ctext = ctext.to_bytes((ctext.bit_length()+7)//8, byteorder = 'big')
  cipher = AES.new(key, AES.MODE_CTR, nonce=ctext[0:nonce_len])
  dtext = cipher.decrypt(ctext[nonce_len:])
  decrypt_text = dtext.decode('utf-8')
  return decrypt_text

#TO REGISTER FOR THE SECOND PHASE UNCOMMENT THIS PART:
'''
s, h = SignSL(str(stuID))

####Register Long Term Key
mes = {'ID': 25427, 'H': h, 'S': s, 'LKEY.X': QCli_long.x, 'LKEY.Y': QCli_long.y}
response = requests.put('{}/{}'.format(API_URL, "RegLongRqst"), json = mes)
print(response.json())
code = input()

mes = {'ID': 25427, 'CODE': code}
response = requests.put('{}/{}'.format(API_URL, "RegLong"), json = mes)
print(response.json())'''


#TO DELETE THE LONG TERM KEY UNCOMMENT THIS PART:
'''
###########DELETE LONG TERM KEY
# If you lost your long term key, you can reset it yourself with below code.

# First you need to send a request to delete it. 
mes = {'ID': stuID}
response = requests.get('{}/{}'.format(API_URL, "RstLongRqst"), json = mes)
print(response.json())
code = input()

#Then server will send a verification code to your email. 
# Send this code to server using below code
mes = {'ID': stuID, 'CODE': code}
response = requests.get('{}/{}'.format(API_URL, "RstLong"), json = mes)

#Now your long term key is deleted. You can register again.
'''

#RESET OF THE EPHEMERAL KEYS. UNCOMMENT THIS FOLLOWING BLOCK IF NECESSARY
"""
s, h = SignSL(str(stuID))
mes = {'ID': stuID, 'S': s, 'H': h}
response = requests.get('{}/{}'.format(API_URL, "RstEKey"), json = mes)
"""

#SEND 10 EPHEMERAL KEYS TO SERVER, UNCOMMENT THIS BLOCK TOO IF YOU RESET YOUR EPHEMERAL KEYS TO CREATE NEW ONES
"""
Dict = {} #dictionary of the ephemeral key id and the corresponding private ephemeral key

for i in range(10): #10 ephemeral key generations

  sA = Random.new().read(int(math.log(q-1,2)))
  sA = int.from_bytes(sA, byteorder='big') % q

  Dict[i] = sA

  ekey = sA*P
  toMessage = str(ekey.x) + str(ekey.y)
  s, h = SignSL(toMessage)

  #send ephemeral key
  mes = {'ID': stuID, 'KEYID': i , 'QAI.X': ekey.x, 'QAI.Y': ekey.y, 'Si': s, 'Hi': h}
  response = requests.put('{}/{}'.format(API_URL, "SendKey"), json = mes)
"""

#this dictionary stores the id of the ephemeral key and the corresponding private ephemeral key, hardcoded version of the previous execution
Dict = {0: 16312126299964990973584683737918314135794607234889937139336617376896832137435, 1: 99274537436684975360293826950900279234239922153770791729828030528762053202478, 2: 73915993245199848290595145600505803324368436145784310565885200538639806891768, 3: 77940808789657353050761742251733108903882076341703934678313417287397093888373, 4: 41966767933111510004398917426641000077015270331259422083466552107205589748806, 5: 52716700601480350966554106577764564405800750394486783552844437178892492778338, 6: 75791391883463602956572588278699878049426190180979553268371380899948950390898, 7: 95440072510174686350960126870427465315550320275255720629613623843869863959532, 8: 111483338586532351974358917355413263204998247811088230037223373499697671417612, 9: 83921132134867934916105855632012885030166783384674159811478639955168656508519}


print("Dictionary that keeps the ephemeral private keys with the ID =", Dict)
print()


#We will get 5 messages from server, current set of messages will be stored inside listOfMessages

listOfMessages = []

for i in range(5):
  s,h = SignSL(str(stuID))

  #Receiving Messages
  mes = {'ID_A': stuID, 'S': s, 'H': h}
  response = requests.get('{}/{}'.format(API_URL, "ReqMsg"), json = mes)

  listOfMessages.append(response.json())


print("List of messages received =", listOfMessages)
print()

#decrypt messages
for i in listOfMessages:
  keyID = int(i.get('KEYID')) 
  message = i.get('MSG')
  #ephemeral public key of the pseudo-client
  QBj_x = i.get('QBJ.X')
  QBj_y = i.get('QBJ.Y')
  QBj = Point(QBj_x, QBj_y, curve)

  sA = Dict[keyID]
  T = sA * QBj
  message_for_U = "NoNeedToRunAndHide"
  U = str(T.x) + str(T.y) + message_for_U

  hashVal= SHA3_256.new(bytes(U, 'utf-8'))
  k_enc = hashVal.digest()

  hashVal_ = SHA3_256.new(k_enc)
  k_mac = hashVal_.digest()

  #Whole message with nonce-message itself-hmac is converted into byte array
  msg_bytes = message.to_bytes((message.bit_length() + 7)//8, byteorder= 'big')
  #Last 32 bytes is the hmac
  HMAC_extracted = msg_bytes[len(msg_bytes)-32:]
  #First portion is the nonce and the message itself
  message_withnonce = msg_bytes[:len(msg_bytes)-32]
  #message without nonce to get the MAC of the message
  message_without_nonce = msg_bytes[8:len(msg_bytes)-32]
  #message in int format to decrypt it
  message_int = int.from_bytes(message_withnonce, 'big')

  #get the HMAC-SHA256 of the message with k_mac
  HMAC_val = HMAC.new(k_mac, message_without_nonce, digestmod=SHA256)
  hmac = HMAC_val.digest()

  #if the mac computed and mac extracted from the message are the same then the message is authenticated
  if hmac == HMAC_extracted:
    print("The MAC of the message is verified, it is authentic!")
  else:
    print("The message is not authentic!")

  decrypted_text = Decryption(message_int, k_enc, 8)
  print("The decrypted message is:", decrypted_text)

  #send decrypted messages to server
  mes = {'ID_A': stuID, 'DECMSG': decrypted_text}
  response = requests.put('{}/{}'.format(API_URL, "Checker"), json = mes)
  print(response.json())
  print()

print("Yes, we loved the songs!")